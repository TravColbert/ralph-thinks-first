# Ralph-Thinks-First

## Overview

Ralph-Thinks-First (RTF) is a bash-driven agentic framework that formalizes ideation and project definition before execution. Designed around the belief that effective AI agents require clear scope, intent, and task breakdowns—just like human software teams.

RTF uses a single, general-purpose script—`agent.sh`—that adapts its behavior based on a **role file**. Roles define the agent's persona, instructions, and capabilities. A **Manager** role orchestrates the workflow by invoking specialized sub-agents (Architect, Coder, Documentor) as child processes.

> **Note:** The previous `principal.sh` and `ralph.sh` scripts have been deprecated. All functionality is now provided by `agent.sh` with the appropriate role file.

---

## `agent.sh` — The Unified Agent Runner

`agent.sh` is a general-purpose agent loop. It loads a role definition, reads a task file, and runs an iterative session with an LLM (Claude). Depending on its configuration, it can operate interactively (prompting the user each iteration) or autonomously.

### How it Works

1.  **Initialization**: The script loads a role file (`-r`) that defines the agent's persona and instructions, and a task file (`-t`) that provides the work context.
2.  **Iteration Loop**: Each iteration:
    *   In `--interactive` mode, the user is prompted for input. In autonomous mode, the agent works from the task file alone.
    *   The script constructs a prompt combining the role definition, current task file contents, and conversation history.
    *   The LLM response is parsed for:
        *   **Task file updates**: Content between `---BEGIN TASKS.MD---` and `---END TASKS.MD---` markers is written back to the task file.
        *   **Sub-agent invocations**: An `**INVOKE**:` directive triggers a child `agent.sh` process (used by the Manager role).
        *   **Completion signal**: The text `**AGENT COMPLETE**` ends the session.
3.  **Termination**: The loop ends when the agent signals completion, the user types `exit`/`quit` (interactive mode), or the maximum iteration count is reached.

### Usage

```bash
./agent.sh [OPTIONS]
```

| Option | Description | Default |
|---|---|---|
| `-r, --role FILE` | Path to the role file | `MANAGER.md` |
| `-t, --task FILE` | Path to the task file | `TASKS.md` |
| `-p, --prompt 'TEXT'` | Initial prompt / instructions | *(none)* |
| `-m, --model MODEL` | Claude model to use | `sonnet` |
| `--max-iterations N` | Maximum loop iterations | `10` |
| `--interactive` | Prompt the user for input each iteration | *(off)* |
| `-h, --help` | Show help message | |

---

## Roles

Roles are Markdown files that define an agent's behavior. Each role is passed to `agent.sh` via the `-r` flag.

### Manager (`MANAGER.md`)

The orchestrator. The Manager reads the task file, decides which sub-agent to invoke next, and drives the project to completion. It invokes sub-agents using `**INVOKE**:` directives and regains control after each sub-agent finishes.

Typical workflow: Architect → Coder → Documentor → **AGENT COMPLETE**.

### Architect (`ARCHITECT.md`)

Runs interactively (`--interactive`). Interviews the user to refine a project idea into a detailed, actionable task list with clear success parameters. Outputs structured `TASKS.md` content between `---BEGIN TASKS.MD---` / `---END TASKS.MD---` markers.

### Coder (`CODER.md`)

Runs autonomously. Works through unchecked tasks (`- [ ]`) in the task file, completes each one, marks it done (`- [x]`), and signals `**AGENT COMPLETE**` when finished. Conversation history is intentionally omitted to keep prompts focused.

### Documentor (`DOCUMENTOR.md`)

Runs autonomously. Reads a source code file (passed as the task file) and produces Markdown documentation in the `documents/` folder. Flags spurious or questionable code in an `## INVESTIGATE and CLARIFY` section.

---

## Project Structure

*   `agent.sh`: The unified agent runner script.
*   `MANAGER.md`: Role file for the project management / orchestration agent.
*   `ARCHITECT.md`: Role file for the system architect agent.
*   `CODER.md`: Role file for the coding agent.
*   `DOCUMENTOR.md`: Role file for the documentation agent.
*   `TASKS.md`: The project plan file, generated by the Architect and consumed by the Coder.
*   `documents/`: Output folder for documentation produced by the Documentor.

## Example Workflow

The simplest way to run a full project is to start the Manager, which orchestrates the other agents:

```bash
./agent.sh -r MANAGER.md -t TASKS.md -p "Create a simple Python web server."
```

The Manager will:
1.  Invoke the **Architect** (`--interactive`) to interview you and build the task list.
2.  Invoke the **Coder** to implement each task autonomously.
3.  Invoke the **Documentor** for each source file produced.
4.  Signal `**AGENT COMPLETE**` when the project is done.

You can also invoke individual roles directly:

```bash
# Interactive ideation session
./agent.sh -r ARCHITECT.md -t TASKS.md --interactive -p "Build a REST API"

# Autonomous coding session
./agent.sh -r CODER.md -t TASKS.md

# Document a source file
./agent.sh -r DOCUMENTOR.md -t src/main.py
```
